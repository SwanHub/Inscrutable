For the first method, shift, we're going to use a mod function. The mod function
provides the necessary circularity. It closes the loop of our sequence.

I feel like introducing mod means that each time the board is calculated or
acted upon, it's actually acting upon a mod equation. No static numbers...

We'll see. The thing is if we take the mod9 of [1..9], we get [0..8], which have
the same length, but different numeric properties. Interesting.

Bam... so that works well. Some basic mod addition...

I finished the basics of the first method... shift. We use a basic equation
and an enumerator to accomplish the task. Also, importantly, since our mod
system relies on converting the cycle from 0..8 to 1..9 each time, we need our
first, current array to be 0..8 and not 1..9 which it was. That cleaned up a minor bug. And another bug that popped up was I didn't have parentheses around the correct elements of the mod equation. As a result, order of operations
went to work on the wrong shit. Bugs fixed, the first quarter of the meat of the program's function is working.

Here's the reason why the above does not work: when you calculate directly on the number and the whole puzzle isn't in order, you get wacky ass answers. Because you're these are not VALUE equations we're making... these are index operations. We are MOVING indexes, not manipulating values. It's good, though, because the mod system will actually work quite well on them... I won't have to create a 0..8 array and manipulate the values each time its acted upon. i can work simultaneously with the 0..8 indexes which will represent the numbers on a 1..9 scale.

conclusion of day 1: made headway in the first method. Next step is working with the indexes as opposed to the value themselves. Applying the principles already discovered.

Day 2

shift() method now works. By changing the transform to a transform based on the indexes, as opposed to the values, the method has become 100% stable.

Day 3

A fun enumerator to use is: .cycle()... another looping element.
.insert :: insert an object before another. array.insert(2, 99) inserts @ index 2 "99"

Day 4

Finished the "single_swap" method.
Hung up on jump method due to interesting thing I just learned: the mod of a
negative number is not the mod of the abs value of the negative number. It
appears to be the modular + the negative number. So -2 % 9 = 7... let's see if
removing the mod helps.

I now have jump() working quite well. All methods, in fact, are operational.

I also am now fully operational on the global variable front. Let's see if I
can call two methods in a row.

What's great is in this new game, we've already incorporated something new ---
the global variable. I'm happy about that. I can then apply that to my tic-tac-toe and get that game all in shape and more beautiful. A good bit of work tonight, finishing the basic methods jump and single_swap.

Day 5

Here's a good problem we're running into. You can't store a method inside an array without the method being called.

"What you're storing in the array is the result of the methods, not the methods themselves."

Check this further funky business out... if you define a method that defines an array full of methods, then I am for some reason calling the methods within the array twice... even though I only ever actually call the function once... then when I remove the function_choice from being called, I get nothing (which makes sense because nothing was called). Mystery to solve.

At the thought of using method(:jump) and jump.call... I would entertain an alternative solution to storing methods...

The goal is to randomly call a method.

I've goofed somewhere. Even when I remove everything and just call a shift(-1, 2)
I'm getting a double print of the method for some reason...

does it have to do with "require" ? :: Answer: yes. For some reason which I have absolutely no inkling of a reason for... when you remove the "require "./inscrutable.rb", you also remove the second call to print the method. It's as if linking two pages together calls the action twice... need to do some research on "require"

So this works pretty well, interestingly enough. You can store a method itself by stating method(:method_name)... no action takes place. The method is simply ready to pounce when called. good for storing methods inside arrays. 
