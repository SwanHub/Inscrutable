For the first method, shift, we're going to use a mod function. The mod function
provides the necessary circularity. It closes the loop of our sequence.

I feel like introducing mod means that each time the board is calculated or
acted upon, it's actually acting upon a mod equation. No static numbers...

We'll see. The thing is if we take the mod9 of [1..9], we get [0..8], which have
the same length, but different numeric properties. Interesting.

Bam... so that works well. Some basic mod addition...

I finished the basics of the first method... shift. We use a basic equation
and an enumerator to accomplish the task. Also, importantly, since our mod
system relies on converting the cycle from 0..8 to 1..9 each time, we need our
first, current array to be 0..8 and not 1..9 which it was. That cleaned up a minor bug. And another bug that popped up was I didn't have parentheses around the correct elements of the mod equation. As a result, order of operations
went to work on the wrong shit. Bugs fixed, the first quarter of the meat of the program's function is working.

Here's the reason why the above does not work: when you calculate directly on the number and the whole puzzle isn't in order, you get wacky ass answers. Because you're these are not VALUE equations we're making... these are index operations. We are MOVING indexes, not manipulating values. It's good, though, because the mod system will actually work quite well on them... I won't have to create a 0..8 array and manipulate the values each time its acted upon. i can work simultaneously with the 0..8 indexes which will represent the numbers on a 1..9 scale.

conclusion of day 1: made headway in the first method. Next step is working with the indexes as opposed ot the value themselves. Applying the principles already discovered.

Day 2

shift() method now works. By changing the transform to a transform based on the indexes, as opposed to the values, the method has become 100% stable.

Day 3

A fun enumerator to use is: .cycle()... another looping element.
.insert :: insert an object before another. array.insert(2, 99) inserts @ index 2 "99"

Day 4

Finished the "single_swap" method.
Hung up on jump method due to interesting thing I just learned: the mod of a
negative number is not the mod of the abs value of the negative number. It
appears to be the modular + the negative number. So -2 % 9 = 7... let's see if
removing the mod helps.

I now have jump() working quite well. All methods, in fact, are operational.

I also am now fully operational on the global variable front. Let's see if I
can call two methods in a row.

### DEFINING THE GAME FLOW ###

1. Welcome the user "hello, welcome to inscrutable"
