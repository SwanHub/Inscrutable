For the first method, shift, we're going to use a mod function. The mod function
provides the necessary circularity. It closes the loop of our sequence.

I feel like introducing mod means that each time the board is calculated or
acted upon, it's actually acting upon a mod equation. No static numbers...

We'll see. The thing is if we take the mod9 of [1..9], we get [0..8], which have
the same length, but different numeric properties. Interesting.

Bam... so that works well. Some basic mod addition...

I finished the basics of the first method... shift. We use a basic equation
and an enumerator to accomplish the task. Also, importantly, since our mod
system relies on converting the cycle from 0..8 to 1..9 each time, we need our
first, current array to be 0..8 and not 1..9 which it was. That cleaned up a minor bug. And another bug that popped up was I didn't have parentheses around the correct elements of the mod equation. As a result, order of operations
went to work on the wrong shit. Bugs fixed, the first quarter of the meat of the program's function is working.

Here's the reason why the above does not work: when you calculate directly on the number and the whole puzzle isn't in order, you get wacky ass answers. Because you're these are not VALUE equations we're making... these are index operations. We are MOVING indexes, not manipulating values. It's good, though, because the mod system will actually work quite well on them... I won't have to create a 0..8 array and manipulate the values each time its acted upon. i can work simultaneously with the 0..8 indexes which will represent the numbers on a 1..9 scale.

conclusion of day 1: made headway in the first method. Next step is working with the indexes as opposed to the value themselves. Applying the principles already discovered.

Day 2

shift() method now works. By changing the transform to a transform based on the indexes, as opposed to the values, the method has become 100% stable.

Day 3

A fun enumerator to use is: .cycle()... another looping element.
.insert :: insert an object before another. array.insert(2, 99) inserts @ index 2 "99"

Day 4

Finished the "single_swap" method.
Hung up on jump method due to interesting thing I just learned: the mod of a
negative number is not the mod of the abs value of the negative number. It
appears to be the modular + the negative number. So -2 % 9 = 7... let's see if
removing the mod helps.

I now have jump() working quite well. All methods, in fact, are operational.

I also am now fully operational on the global variable front. Let's see if I
can call two methods in a row.

What's great is in this new game, we've already incorporated something new ---
the global variable. I'm happy about that. I can then apply that to my tic-tac-toe and get that game all in shape and more beautiful. A good bit of work tonight, finishing the basic methods jump and single_swap.

Day 5

Here's a good problem we're running into. You can't store a method inside an array without the method being called.

"What you're storing in the array is the result of the methods, not the methods themselves."

Check this further funky business out... if you define a method that defines an array full of methods, then I am for some reason calling the methods within the array twice... even though I only ever actually call the function once... then when I remove the function_choice from being called, I get nothing (which makes sense because nothing was called). Mystery to solve.

At the thought of using method(:jump) and jump.call... I would entertain an alternative solution to storing methods...

The goal is to randomly call a method.

I've goofed somewhere. Even when I remove everything and just call a shift(-1, 2)
I'm getting a double print of the method for some reason...

does it have to do with "require" ? :: Answer: yes. For some reason which I have absolutely no inkling of a reason for... when you remove the "require "./inscrutable.rb", you also remove the second call to print the method. It's as if linking two pages together calls the action twice... need to do some research on "require"

So this works pretty well, interestingly enough. You can store a method itself by stating method(:method_name)... no action takes place. The method is simply ready to pounce when called. good for storing methods inside arrays.

Ending with the difficulty of how to STORE a method with tbh input values... how to store a method that takes parameters...

Day 6

Some good news after testing:
You can set a var equal to a sample from an array and if you loop through that sequence multiple times, the variable value is not saved. I.e. you can use this sampling as the basis for the loop mechanism...

ALSO, I figured out the mechanism for this .call action... instead of trying to pass through the arguments to the array, pass through the arguments when you are using the .call function... like this: array[0].call(argument1, argument2)

GENIUS!

Well, so now I have two methods to get the same thing done. very nice... let me see if I can put a random sampling in there... YES! That works as well.

full breakthrough today with the method saving and calling...

In this project, we've already added an understanding of this new procedure for calling methods, whereby you use method(:method_name) and then call the method with array_of_methods[index].call(argument1, argument2). We are also using the .sample method for getting a random selection from an array. Excellent.

Testing bugs: 4 is the culprit. Incorrectly creates several "nil" values within the $current_board array.

I feel like the issue has primarily to do with jumping to the right when there is nothing to the right. I need to change the parameters of a jump from being definite within a range to being derived within a range. I do have a good plan b for this anyway, which is to simply remove any nils which appear.

The next challenge will be to create an "unscramble" method. Scramble has been created, along with the methods for transforming the array sequence.

I also want to encapsulate all of the welcome messages in methods so that my run script can be as absolutely clean as possible. 
