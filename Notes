Day 1

Planning

Day 2

shift() method now works.
  (I could have used .rotate method.)

Day 3

.insert :: insert an object before another. array.insert(2, 99) inserts @ index 2 "99"

Day 4

Finished the "single_swap" method.

Hung up on jump method due to mods of negative numbers.

### Need to research mods of negative numbers...
  -17%12 = 7
  -17%16 = 15
###

I now have jump() working quite well. All methods are operational.

Global variables also working. First time I've used those. Will go back and
change tic-tac-toe to include global variables.

Day 5

The goal is to randomly call a method from the array.

Good obstacle: can't store a method inside an array without the method being called.

Stack Overflow:
"What you're storing in the array is the result of the methods, not the methods themselves."

Check this further funky business out... if you define a method that defines an array full of methods, then I am for some reason calling the methods within the array twice... even though I only ever actually call the function once...

Stack Overflow yielding answer: use method(:jump) and jump.call...

I've goofed somewhere. Even when I remove everything and just call a shift(-1, 2)
I'm getting a double print of the method for some reason...

does it have to do with "require" ?
  Answer: yes. When you remove the "require './inscrutable.rb'", you also remove the second call to print the method. It's as if linking two pages together calls the action twice... need to do some research on "require".

Ending with the difficulty of how to STORE a method with tbh input values... how to store a method that takes parameters...

Day 6

Goal: call a stored method.

Answer: pass arguments at the moment you use the .call function... like this: array[0].call(argument1, argument2)

In this project, we've already added an understanding of this new procedure for calling methods, whereby you use method(:method_name) and then call the method with array_of_methods[index].call(argument1, argument2). We are also using the .sample method for getting a random selection from an array.

Testing bugs: 4 is the culprit. Incorrectly creates several "nil" values within the $current_board array.

Random scramble method is complete.

Day 7

Created an unscramble method.

Jump() method has more power than other methods.

Finishing touches:
-- Remove display messages from the inside of the unscramble loop... just test
   for correct sequence and then break the sequence if user is correct.
-- Loop the entire scramble // unscramble sequence.
-- Display how many moves the user has left.
-- Create safety mechanism for mistaken number entry. (could be best solved with
   an options menu gem for each move.)
-- For losing games, show the board with associated incorrect positions... an
   'X' under all incorrect indexes.

1.0 FINISHED ___________________________ NOW FOR USER TESTING

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
IMPROVEMENTS FOR 2.0, BASED ON USER RESPONSE

-- Keep track of time.

  (Would need to calculate the difficulty of a generated board)

  1. Loop through all possible possible winning combinations of transformations.
     Store each winning sequence in an array. Count number of sequences.
  2. Determine a way to calculate the difficulty of the board on the spot,
     based on adjacency.

-- You accumulate points.
     + log points via multiplier (based on time) * # of moves (where applicable)
-- High scores on individual levels are saved (cli gem)
-- Jump and shift methods can be compressed. (-5 vs. -1*5)
-- Options menu (cli gem)

Realistically, before moving on to the next project, here are the things I want
to change:
  - In scramble(), should deny "same state" transformations. DONE
      (ensures the board is at least 4-move difficult)
  - fix jump method over array.length threshold. DONE
  - compress jump and shift methods. DONE
  - options menu gem DONE
  - saving high scores (times) gem
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
